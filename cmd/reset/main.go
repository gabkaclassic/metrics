package main

import (
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type (
	packageTemplate struct {
		Pkg      string
		Entities []entity
		UseReset bool
	}
	entity struct {
		Typ    string
		Fields []field
	}
	field struct {
		Name  string
		Value string
	}
)

const resetMethodsTemplate = `// Code generated by go generate; DO NOT EDIT.
// This file was generated by genreset.

package {{.Pkg}}

{{- if .UseReset}}
import "github.com/gabkaclassic/metrics/pkg/reset"
{{- end}}
{{range .Entities}}
func (e *{{.Typ}}) Reset() {
{{- range .Fields}}
	{{.Value}}
{{- end}}
}
{{end}}
`

var tmpl = template.Must(template.New("reset").Parse(resetMethodsTemplate))

func getBaseType(expr ast.Expr) ast.Expr {
	for {
		switch e := expr.(type) {
		case *ast.StarExpr:
			expr = e.X
		case *ast.ParenExpr:
			expr = e.X
		case *ast.IndexExpr:
			expr = e.X
		case *ast.IndexListExpr:
			expr = e.X
		case *ast.SelectorExpr:
			expr = e.Sel
		default:
			return expr
		}
	}
}

func resetStmt(temp *packageTemplate, name string, typ ast.Expr) string {

	typ = getBaseType(typ)

	switch t := typ.(type) {

	case *ast.MapType:
		return "clear(e." + name + ")"

	case *ast.ArrayType:
		return "e." + name + " = e." + name + "[:0]"

	case *ast.Ident:
		switch t.Name {
		case "string":
			return `e.` + name + ` = ""`
		case "bool":
			return "e." + name + " = false"
		case "int", "int8", "int16", "int32", "int64",
			"uint", "uint8", "uint16", "uint32", "uint64",
			"byte", "rune", "float32", "float64", "complex64", "complex128":
			return "e." + name + " = 0"
		default:
			temp.UseReset = true
			return `if r, ok := e.` + name + `.(reset.Resetable); ok {
		r.Reset()
	}`
		}

	case *ast.StructType, *ast.InterfaceType:
		temp.UseReset = true
		return `if r, ok := e.` + name + `.(reset.Resetable); ok {
		r.Reset()
	}`

	case *ast.FuncType, *ast.ChanType:
		return "e." + name + " = nil"

	default:

		return "e." + name + " = nil"
	}
}

func main() {
	fset := token.NewFileSet()
	pkgs := map[string]*packageTemplate{}

	filepath.WalkDir(".", func(path string, d os.DirEntry, err error) error {
		if err != nil || d.IsDir() || !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, ".gen.go") {
			return nil
		}

		file, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return nil
		}

		dir := filepath.Dir(path)
		if _, ok := pkgs[dir]; !ok {
			pkgs[dir] = &packageTemplate{Pkg: file.Name.Name}
		}

		for _, decl := range file.Decls {
			gen, ok := decl.(*ast.GenDecl)
			if !ok || gen.Tok != token.TYPE || gen.Doc == nil {
				continue
			}

			hasMarker := false
			for _, c := range gen.Doc.List {
				if strings.Contains(c.Text, "generate:reset") {
					hasMarker = true
					break
				}
			}
			if !hasMarker {
				continue
			}

			for _, spec := range gen.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				st, ok := ts.Type.(*ast.StructType)
				if !ok {
					continue
				}

				ent := entity{Typ: ts.Name.Name}
				for _, f := range st.Fields.List {
					if len(f.Names) == 0 {
						continue
					}
					for _, n := range f.Names {
						ent.Fields = append(ent.Fields, field{
							Name:  n.Name,
							Value: resetStmt(pkgs[dir], n.Name, f.Type),
						})
					}
				}

				pkgs[dir].Entities = append(pkgs[dir].Entities, ent)
			}
		}

		return nil
	})

	for dir, pt := range pkgs {
		if len(pt.Entities) == 0 {
			continue
		}

		out := filepath.Join(dir, "reset.gen.go")
		f, err := os.Create(out)
		if err != nil {
			continue
		}

		_ = tmpl.Execute(f, pt)
		_ = f.Close()
	}
}
